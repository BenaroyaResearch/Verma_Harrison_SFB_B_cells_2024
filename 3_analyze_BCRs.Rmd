---
title: "Single-cell RNAseq (10x) of SFB-specific B cells from mice, with BCR sequencing: analysis of BCR sequences"
author: "Matt Dufort"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 5
    df_print: paged
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body{ /* Normal  */
      font-size: 14px;
  }
h1 { /* Header 1 */
  font-size: 28px;
}
h2 { /* Header 2 */
    font-size: 24px;
}
h3 { /* Header 3 */
  font-size: 20px;
}
h4 { /* Header 4 */
  font-size: 16px;
}
</style>

# Project Summary

This script includes analyses used in Verma et al. 2023 (https://doi.org/10.1101/2023.10.13.562275). The data are from 10x Genomics sequencing of SFB-specific B cells from mouse Peyer's patches. Data include both single-cell RNAseq and paired BCR sequencing. The samples contain cells from 10 mice, multiplexed using hashtag barcoding.

This script uses outputs from the Immcantation toolkit to generate trees and logo plots of BCR clones.

```{r setup, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE}
if (!require(knitr)) install.packages("knitr"); library(knitr)

# data munging and coding tools
if (!require(tidyverse)) install.packages("tidyverse"); library(tidyverse)
if (!require(magrittr)) install.packages("magrittr"); library(magrittr)

# visualization tools
if (!require(kableExtra)) install.packages("kableExtra"); library(kableExtra)
if (!require(plotscale)) install.packages("plotscale"); library(plotscale)

# Seurat
if (!require(Seurat)) install.packages("Seurat"); library(Seurat)

# BCR analysis tools
if (!require(dowser)) install.packages("dowser"); library(dowser)
if (!require(phangorn)) install.packages("phangorn"); library(phangorn)
if (!require(Biostrings)) {
  if (!require(BiocManager)) install.packages("BiocManager")
  BiocManager::install("Biostrings")}
library(Biostrings)
if (!require(ggtree)) {
  if (!require(BiocManager)) install.packages("BiocManager")
  BiocManager::install("ggtree")}
library(ggtree)
if (!require(ggseqlogo)) {
  if (!require(remotes)) install.packages("remotes")
  remotes::install_github("omarwagih/ggseqlogo")}
library(ggseqlogo)

# Custom packages
if (!require(miscHelpers)) {
  if (!require(remotes)) install.packages("remotes")
  remotes::install_github("BenaroyaResearch/miscHelpers")}
library(miscHelpers)

# set Rmarkdown options
opts_chunk$set(
  fig.width = 6, fig.height = 4.25, 
  cache = TRUE, # caching does not work with large Seurat objects
  echo = FALSE, warning = FALSE, message = FALSE)
options(stringsAsFactors = FALSE)

# set default theme for plots
theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
          axis.text = element_text(colour = "black"),
          axis.ticks = element_line(colour = "black"),
          axis.text.x = element_text(angle = 0)))
update_geom_defaults("point", list(shape = 16))
grDevices::pdf.options(useDingbats = FALSE)
```

```{r setFilenamesAndGlobalVariables}
dirRoot <- file.path("~", "SFB_B_cells_10x")

# set directory from which to load data
dirData <- file.path(dirRoot, "data")

# set (and create) directory for plot output
dirPlots <- file.path(dirRoot, "plots")
if (!dir.exists(dirPlots)) dir.create(dirPlots)

# set (and create) directory for saved data
dirDataSaved <- file.path(dirRoot, "data_saved")
if (!dir.exists(dirDataSaved)) dir.create(dirDataSaved)
```

```{r setDirectory, cache=FALSE}
opts_knit$set(root.dir = dirRoot)
setwd(dirRoot)
```

# Load data generated in previous R script

```{r loadPreviousData, cache=FALSE}
# load data generated in previous R script
load(file.path(dirDataSaved, "data10x.RData"))
```

# BCR diversity and lineage inference

## BCR lineage inference using immcantation toolkit, for clones split by mouse

### Load AIRR-formatted data with clones and germlines

NOTE: The code will error out at this point if the upstream R script and Immcantation tools have not yet been run, as those upstream steps generate files that must be used as input here.

This loads files generated by a set of scripts from the Immcantation toolkit. That set of scripts identifies gene loci, parses files into heavy and light chains, uses the clone separation distance determined above to define clones, uses the light chain sequences to filter clones to only those with common light chain usage, and infers germline sequences.

```{r loadData10xClonesAirrHeavyChainOnly, dependson="loadPreviousData"}
# get list of files with full germline alignment
fileListData10xClonesAirrHeavyChainOnlyGermlineFull <-
  dir(file.path(dirOutputFilteredContigFastaFilteredSplit, "germline_full")) %>%
  grep(pattern = "igblast_final-clone-pass_germ-pass\\.tsv", value = TRUE) %>%
  file.path(dirOutputFilteredContigFastaFilteredSplit, "germline_full", .)

# get list of files with germline D region masked
fileListData10xClonesAirrHeavyChainOnlyGermlineDMask <-
  str_replace(
    fileListData10xClonesAirrHeavyChainOnlyGermlineFull, 
    "germline_full", "germline_d_mask")

# set trait columns to keep
traitColsData10xClones <-
  c("isotypeFromBcrHChain", "seuratClustersRna",
    "junction", "junction_aa")

# load heavy chain files
data10xClonesAirrHeavyChainOnly <- list()
for (i in 1:length(fileListData10xClonesAirrHeavyChainOnlyGermlineFull)) {
  data10xClonesAirrHeavyChainOnly[[
    str_extract(fileListData10xClonesAirrHeavyChainOnlyGermlineFull[i], "mouse[0-9]+")]] <-
    readr::read_tsv(
      file.path(
        fileListData10xClonesAirrHeavyChainOnlyGermlineFull[i])) %>%
    # merge info from earlier analysis of cells (clusters, isotype, cell cycle phase)
    left_join(
      data10x@meta.data %>%
        dplyr::select(
          cell_id = cellBarcode, any_of(traitColsData10xClones))) %>%
    mutate(cellBarcode = str_extract(sequence_id, "[ACGT]+\\-[0-9]+")) %>%
    # pull in version with germline alignment with D region masked, and merge it
    left_join(
      readr::read_tsv(
        file.path(
          fileListData10xClonesAirrHeavyChainOnlyGermlineDMask[i])) %>%
        dplyr::select(sequence_id, germline_alignment_d_mask))
}
data10xClonesAirrHeavyChainOnly <-
  data10xClonesAirrHeavyChainOnly[
    str_sort(names(data10xClonesAirrHeavyChainOnly), numeric=TRUE)]

rm_tmp(ask=FALSE)
```

```{r loadData10xClonesAirrLightChainOnly, dependson=c("loadData10xClonesAirrHeavyChainOnly", "loadPreviousData")}
# get list of files with light chain info
fileListData10xClonesAirrLightChainOnly <-
  dir(file.path(dirOutputFilteredContigFastaFilteredSplit)) %>%
  grep(pattern = "light_igblast_db-pass\\.tsv", value = TRUE) %>%
  file.path(dirOutputFilteredContigFastaFilteredSplit, .)

# load light chain files
data10xClonesAirrLightChainOnly <- list()
for (i in 1:length(fileListData10xClonesAirrLightChainOnly)) {
  data10xClonesAirrLightChainOnly[[
    str_extract(fileListData10xClonesAirrLightChainOnly[i], "mouse[0-9]+")]] <-
    readr::read_tsv(
      file.path(
        fileListData10xClonesAirrLightChainOnly[i])) %>%
    # merge info from earlier analysis of cells (clusters, isotype, cell cycle phase)
    left_join(
      data10x@meta.data %>%
        dplyr::select(
          cell_id = cellBarcode, any_of(traitColsData10xClones))) %>%
    mutate(cellBarcode = str_extract(sequence_id, "[ACGT]+\\-[0-9]+"))
}
data10xClonesAirrLightChainOnly <-
  data10xClonesAirrLightChainOnly[
    str_sort(names(data10xClonesAirrLightChainOnly), numeric=TRUE)]

rm_tmp(ask=FALSE)
```

```{r mergeLightChainInfoData10xClonesAirr, dependson=c("loadData10xClonesAirrHeavyChainOnly", "loadData10xClonesAirrLightChainOnly", "loadPreviousData")}
data10xClonesAirr <-
  data10xClonesAirrHeavyChainOnly

traitColsData10xClonesLightChain <-
  c("locus", "v_call", "j_call", "c_call", "junction", "junction_aa")

for (sample.tmp in names(data10xClonesAirr)) {
  dataLightChain.tmp <-
    # keep light chains
    data10xClonesAirrLightChainOnly[[sample.tmp]] %>%
    # keep only cells with 1 light chain contig
    group_by(cellBarcode) %>%
    mutate(count = n()) %>%
    dplyr::filter(count == 1)
  data10xClonesAirr[[sample.tmp]] <-
    data10xClonesAirr[[sample.tmp]] %>%
    left_join(
      dataLightChain.tmp %>%
        dplyr::select(
          cellBarcode,
          all_of(traitColsData10xClonesLightChain)) %>%
        magrittr::set_colnames(
          c(colnames(.)[1], paste0(colnames(.)[-1], "_light_chain")))
    )
}

rm_tmp(ask=FALSE)
```

```{r splitData10xClonesAirrByClone, dependson="mergeLightChainInfoData10xClonesAirr"}
# set minimum number of distinct junction amino acid sequences to include a clone
minDistinct.tmp <- 3

data10xClonesAirrSplitByClone <- list()
for (sample.tmp in names(data10xClonesAirr)) {
  data10xClonesAirrSplitByClone[[sample.tmp]] <- list()
  for (clone_id.tmp in unique(data10xClonesAirr[[sample.tmp]]$clone_id)) {
    if (data10xClonesAirr[[sample.tmp]] %>%
        dplyr::filter(clone_id %in% clone_id.tmp) %>%
        dplyr::pull(junction_aa) %>%
        unique() %>%
        length() %>%
        magrittr::is_weakly_greater_than(minDistinct.tmp))
      data10xClonesAirrSplitByClone[[sample.tmp]][[clone_id.tmp]] <-
        data10xClonesAirr[[sample.tmp]] %>%
        dplyr::filter(clone_id %in% clone_id.tmp) %>%
        mutate(cellCount = 1)
  }
}

rm_tmp(ask=FALSE)
```

### Run lineage inference using dowser

```{r formatClonesData10xClonesAirrByClone, dependson="splitData10xClonesAirrByClone"}
data10xClonesAirrSplitByCloneFormatted <- list()

# run formatClones on each clone
for (sample.tmp in names(data10xClonesAirrSplitByClone)) {
  data10xClonesAirrSplitByCloneFormatted[[sample.tmp]] <- list()
  for (clone_id.tmp in names(data10xClonesAirrSplitByClone[[sample.tmp]])) {
    data10xClonesAirrSplitByCloneFormatted[[sample.tmp]][[clone_id.tmp]] <-
      dowser::formatClones(
        data10xClonesAirrSplitByClone[[sample.tmp]][[clone_id.tmp]],
        # may need to modify this to collapse sequences
        # was previously passing traitColsData10xClones as `traits`, which caused the unique values of those fields to be kept separate
        columns = traitColsData10xClones, 
        num_fields = "cellCount",
        germ = "germline_alignment"
      )
  }
}

rm_tmp(ask=FALSE)
```

```{r addSequenceAaData10xClonesAirrByClone, dependson="formatClonesData10xClonesAirrByClone"}
for (sample.tmp in names(data10xClonesAirrSplitByCloneFormatted)) {
  for (clone_id.tmp in names(data10xClonesAirrSplitByCloneFormatted[[sample.tmp]])) {
    data10xClonesAirrSplitByCloneFormatted[[sample.tmp]][[clone_id.tmp]]$data[[1]]@data$sequence_aa <-
      data10xClonesAirrSplitByCloneFormatted[[sample.tmp]][[clone_id.tmp]]$data[[1]]@data$sequence %>%
      lapply(
        \(x) {
          x %>% 
            Biostrings::DNAString() %>%
            Biostrings::translate(if.fuzzy.codon = "solve") %>% 
            as.character()}) %>%
      unlist()
  }
}

rm_tmp(ask = FALSE)
```

#### Build BCR lineage trees from amino acid sequences using P-ratchet

```{r inferTreesAaPratchetData10xClonesAirrByClone, dependson="formatClonesData10xClonesAirrByClone"}
# check for saved version, as this tree inference is time-consuming
filenameData10xClonesAirrSplitByCloneTreesAaPratchet <-
  file.path(
    dirDataSaved,
    "data10xClonesAirrSplitByCloneTreesAaPratchet.RDS")

if (file.exists(filenameData10xClonesAirrSplitByCloneTreesAaPratchet)) {
  data10xClonesAirrSplitByCloneTreesAaPratchet <-
    readRDS(filenameData10xClonesAirrSplitByCloneTreesAaPratchet)
} else {
  data10xClonesAirrSplitByCloneTreesAaPratchet <-
    data10xClonesAirrSplitByCloneFormatted
  # run dowser::getTrees with parsimony ratchet (build = "pratchet") on each clone
  for (sample.tmp in names(data10xClonesAirrSplitByCloneTreesAaPratchet)) {
    for (clone_id.tmp in
         names(data10xClonesAirrSplitByCloneTreesAaPratchet[[sample.tmp]])) {
      # convert germline to amino acid sequence
      data10xClonesAirrSplitByCloneTreesAaPratchet[[sample.tmp]][[clone_id.tmp]]$data[[1]]@germline <-
        data10xClonesAirrSplitByCloneTreesAaPratchet[[sample.tmp]][[clone_id.tmp]]$data[[1]]@germline %>%
        Biostrings::DNAString() %>%
        Biostrings::translate(if.fuzzy.codon = "solve") %>% 
        as.character()
      data10xClonesAirrSplitByCloneTreesAaPratchet[[sample.tmp]][[clone_id.tmp]]$data[[1]]@data$sequence_nt <-
        data10xClonesAirrSplitByCloneTreesAaPratchet[[sample.tmp]][[clone_id.tmp]]$data[[1]]@data$sequence
      data10xClonesAirrSplitByCloneTreesAaPratchet[[sample.tmp]][[clone_id.tmp]]$data[[1]]@data$sequence <-
        data10xClonesAirrSplitByCloneTreesAaPratchet[[sample.tmp]][[clone_id.tmp]]$data[[1]]@data$sequence_aa
      # save nucleotide sequence as sequence_nt, and replace sequence with sequence_aa (necessary due to weird internals of dowser::getTrees)
      data10xClonesAirrSplitByCloneTreesAaPratchet[[sample.tmp]][[clone_id.tmp]] <-
        dowser::getTrees(
          data10xClonesAirrSplitByCloneTreesAaPratchet[[sample.tmp]][[clone_id.tmp]],
          build = "pratchet", seq = "sequence", data_type = "AA")
    }
  }
  
  saveRDS(data10xClonesAirrSplitByCloneTreesAaPratchet,
          file = filenameData10xClonesAirrSplitByCloneTreesAaPratchet)
}

rm_tmp(ask=FALSE)
```

#### Identify clones to focus on

```{r identifyClonesChangeOPublicSelected, dependson=c("loadFilterSplitByChainExportFilteredContigAnnotations", "mergeLightChainInfoData10xClonesAirr", "formatClonesData10xClonesAirrByClone")}
## identify the public clones that were used for downstream testing of antibodies
# clone 1 has heavy chain IGHV1-53 and IGHJ3, light chain IGKV4-58 and IGKJ1, found in mouse2 and mouse8
# clone 2 has heavy chain IGHV1-76 and IGHJ1, light chain IGKV5-43 and IGKJ2, found in mouse5 and mouse8 and mouse9
# keep only the clones that have at least one cell with a BCR light chain matching the clones above
minDistinctPublicSelected.tmp <- 3
clonesChangeOPublicSelected <-
  data10xClonesAirr %>%
  lapply(
    function(x) {
      x %>%
        dplyr::mutate(
          v_gene =
            v_call %>%
            str_remove(",[0-9A-Z\\-\\*]+$") %>% 
            str_remove("\\*[0-9]{2}$"),
          j_gene =
            j_call %>%
            str_remove(",[0-9A-Z\\-\\*]+$") %>% 
            str_remove("\\*[0-9]{2}$"),
          v_gene_light_chain = 
            v_call_light_chain %>%
            str_remove(",[0-9A-Z\\-\\*]+$") %>% 
            str_remove("\\*[0-9]{2}$"),
          j_gene_light_chain =
            j_call_light_chain %>%
            str_remove(",[0-9A-Z\\-\\*]+$") %>% 
            str_remove("\\*[0-9]{2}$")) %>%
        dplyr::filter(
          (v_gene == "IGHV1-53" & j_gene == "IGHJ3" & 
             v_gene_light_chain == "IGKV4-58" & j_gene_light_chain == "IGKJ1") | # clone 358_344 / 359_6
            (v_gene == "IGHV1-76" & j_gene == "IGHJ1" & 
               v_gene_light_chain == "IGKV5-43" & j_gene_light_chain == "IGKJ2") # clone 856_89 / 863_202
        ) %>%
        dplyr::select(
          sequence_id, cell_id, 
          v_gene, j_gene, v_gene_light_chain, j_gene_light_chain,
          junction_aa, clone_id)}
  ) %>%
  bind_rows(.id = "sampleName") %>%
  group_by(sampleName, clone_id) %>%
  mutate(
    nDistinctJunctionAa = n_distinct(junction_aa),
    cloneCount = n(),
    cellCount = NA_integer_) %>%
  dplyr::filter(
    nDistinctJunctionAa >= minDistinctPublicSelected.tmp) %>%
  ungroup() %>%
  group_by(v_gene, j_gene, v_gene_light_chain, j_gene_light_chain) %>%
  mutate(
    cloneGroup = cur_group_id(),
    cloneGroup = 
      factor(cloneGroup, 
             levels = as.character(str_sort(unique(cloneGroup), numeric = TRUE)))) %>%
  ungroup()

# get cellCount for each entry
for (i in seq_len(nrow(clonesChangeOPublicSelected))) {
  sample.tmp <- clonesChangeOPublicSelected$sampleName[i]
  clonesChangeOPublicSelected$cellCount[i] <-
    sum(data10xClonesAirrSplitByCloneFormatted[[sample.tmp]][[clonesChangeOPublicSelected$clone_id[i]]]$data[[1]]@data$cellCount)
}

clonesChangeOPublicSelected <- clonesChangeOPublicSelected %>%
  dplyr::select(
    cloneGroup, sampleName,
    clone_id, v_gene, j_gene, v_gene_light_chain, j_gene_light_chain,
    nDistinctJunctionAa, cloneCount, cellCount) %>%
  unique()

rm_tmp(ask=FALSE)
```

```{r identifyCellsClonesChangeOPublicSelected, dependson="identifyClonesChangeOPublicSelected"}
# generate a data frame of the cells from each mouse in each of the public clones
cellsClonesChangeOPublicSelected <- list()
for (cloneGroup.tmp in levels(clonesChangeOPublicSelected$cloneGroup)) {
  # identify cells included in each clone
  cellsClonesChangeOPublicSelected[[cloneGroup.tmp]] <-
    lapply(
      data10xClonesAirr,
      \(x) {
        x %>%
          dplyr::mutate(
            v_gene =
              v_call %>%
              str_remove(",[0-9A-Z\\-\\*]+$") %>% 
              str_remove("\\*[0-9]{2}$"),
            j_gene =
              j_call %>%
              str_remove(",[0-9A-Z\\-\\*]+$") %>% 
              str_remove("\\*[0-9]{2}$"),
            v_gene_light_chain = 
              v_call_light_chain %>%
              str_remove(",[0-9A-Z\\-\\*]+$") %>% 
              str_remove("\\*[0-9]{2}$"),
            j_gene_light_chain =
              j_call_light_chain %>%
              str_remove(",[0-9A-Z\\-\\*]+$") %>% 
              str_remove("\\*[0-9]{2}$")) %>%
          inner_join(
            clonesChangeOPublicSelected %>%
              dplyr::filter(cloneGroup == cloneGroup.tmp) %>%
              dplyr::select(cloneGroup, v_gene, j_gene, v_gene_light_chain, j_gene_light_chain) %>%
              unique()) %>%
          dplyr::select(cloneGroup, v_gene, j_gene, v_gene_light_chain, j_gene_light_chain, cellBarcode = cell_id)}) %>%
    bind_rows(.id = "sampleName")
}
cellsClonesChangeOPublicSelected <- bind_rows(cellsClonesChangeOPublicSelected)

rm_tmp(ask = FALSE)
```

##### Plot UMAP showing cells colored by clone in each mouse

```{r plotRnaUmapColorByClonesPublicSelectedFacetBySampleName, dependson=c("identifyCellsClonesChangeOPublicSelected", "normalizeClusterProjectRnaData")}
# used in figures
# plot UMAP showing cells colored by clone in each mouse
for (cloneGroup.tmp in levels(cellsClonesChangeOPublicSelected$cloneGroup)) {
  data.tmp <-
    data10x@meta.data %>%
    # pull in clone information
    left_join(
      cellsClonesChangeOPublicSelected %>%
        dplyr::filter(cloneGroup == cloneGroup.tmp) %>%
        dplyr::mutate(cloneFocal = TRUE) %>%
        dplyr::select(cellBarcode, cloneFocal)) %>%
    mutate(cloneFocal = replace_na(cloneFocal, FALSE)) %>%
    # pull in UMAP coordinates
    left_join(
      data10x@reductions$umap_RNA@cell.embeddings %>%
        as.data.frame() %>%
        rownames_to_column("cellBarcode"))
  plot.tmp <-
    ggplot(
      data = 
        data.tmp %>%
        dplyr::arrange(cloneFocal),
      mapping =
        aes(x = umapRNA_1,
            y = umapRNA_2,
            color = cloneFocal, size = cloneFocal)) +
    # geom_point(size = 2.5, alpha = 0.8) +
    geom_point(alpha = 0.8) +
    labs(x = "UMAP 1", y = "UMAP 2") +
    facet_wrap(~sampleName, nrow = 2, labeller = labeller(sampleName = \(x) str_replace(x, "mouse", "mouse "))) +
    scale_color_manual(
      "Cell in\nfocal clone", 
      values = c("TRUE" = "black", "FALSE" = "grey80")) +
    scale_size_manual(
      "Cell in\nfocal clone", 
      values = c("TRUE" = 3.5, "FALSE" = 2.5)) +
    guides(color = guide_legend(override.aes = list(size = 4, alpha = 1))) +
    theme(strip.text = element_text(size = rel(0.8), margin = margin(t = 3, b = 3)))
  # version without axis labels or legend
  plot.tmp <- plot.tmp +
    labs(x = NULL, y = NULL) +
    guides(color = "none", size = "none")
  
  # print(plot.tmp)
  as.pdf(
    plot.tmp,
    file = 
      file.path(
        dirPlots,
        paste("plotRnaUmapColorByClonesPublicSelectedFacetBySampleName", cloneGroup.tmp,
              "pdf", sep = ".")),
    width = 3, height = 3)
}

rm_tmp(ask=FALSE)
```

#### Make logo plots of the CDR3 for the cells from each clone in each mouse

Logo plots for the cells from each of the public clones, regardless of how many cells are in that mouse for that clone.

```{r plotLogoCdr3ClonesChangeOPublicSelectedByCloneMouse, dependson="identifyCellsClonesChangeOPublicSelected"}
# used in figures
if (!require(ggseqlogo)) library(ggseqlogo)

for (cloneGroup.tmp in levels(cellsClonesChangeOPublicSelected$cloneGroup)) {
  pdf(
    file.path(
      dirPlots, 
      paste("plotLogoCdr3ClonesChangeOPublicSelectedByCloneMouse", cloneGroup.tmp,
            "pdf", sep = ".")),
    width = 5, height = 2.7)
  
  # iterate over each mouse and generate logo plot
  seqsCdr3.tmp <- 
    data10xVdj %>%
    inner_join(
      cellsClonesChangeOPublicSelected %>%
        dplyr::filter(cloneGroup == cloneGroup.tmp) %>%
        dplyr::select(sampleName, cellBarcode, v_gene, j_gene)) %>%
    dplyr::select(sampleName, junction_aa)
  
  for (sampleName.tmp in str_sort(unique(seqsCdr3.tmp$sampleName), numeric = TRUE)) {
    plot.tmp <-
      ggplot() +
      geom_logo(seqsCdr3.tmp$junction_aa[seqsCdr3.tmp$sampleName == sampleName.tmp], method = "bits") +
      theme_logo() +
      labs(
        x = "position", 
        title = 
          paste0(
            unique(
              cellsClonesChangeOPublicSelected$v_gene[
                cellsClonesChangeOPublicSelected$cloneGroup == cloneGroup.tmp]), " ",
            unique(
              cellsClonesChangeOPublicSelected$j_gene[
                cellsClonesChangeOPublicSelected$cloneGroup == cloneGroup.tmp]), ", ",
            sampleName.tmp)) +
      theme(legend.text = element_text(size = 7),
            legend.key.size = unit(0.2, "in"))
    print(plot.tmp)
  }
  invisible(dev.off())
}

rm_tmp(ask = FALSE)
```

#### Plot trees for each clone in each mouse, using trees generated by phangorn::pratchet (parsimony ratchet)

```{r plotTreesAaPratchetData10xClonesPublicSelected, dependson=c("inferTreesAaPratchetData10xClonesAirrByClone", "identifyClonesChangeOPublicSelected")}
# figures 5D, 5E

# plot the trees for the clone that Ollie and Sheenam used to make a transgenic mouse
for (i in 1:nrow(clonesChangeOPublicSelected)) {
  # determine sampleName (mouse)
  sampleName.tmp <- clonesChangeOPublicSelected$sampleName[i]
  
  # determine clone_id
  clone_id.tmp <- clonesChangeOPublicSelected$clone_id[i]
  
  # extract data, including tree
  data.tmp <-
    data10xClonesAirrSplitByCloneTreesAaPratchet[[sampleName.tmp]][[clone_id.tmp]]
  
  # set plot title, with mouse and clone, and V/J gene usage for heavy and light chain
  bcrGenesLightChain.tmp <-
    data.tmp$data[[1]]@data %>%
    left_join(
      data10xClonesAirr[[sampleName.tmp]] %>%
        dplyr::select(
          sequence_id,
          any_of(paste0(traitColsData10xClonesLightChain, "_light_chain")))) %>%
    dplyr::select(v_call_light_chain, j_call_light_chain) %>%
    unique()
  if (nrow(bcrGenesLightChain.tmp) == 1) {
    bcrGenesLightChain.tmp <-
      paste(bcrGenesLightChain.tmp$v_call_light_chain[1],
            bcrGenesLightChain.tmp$j_call_light_chain[1],
            sep = ", ")
  } else {
    bcrGenesLightChain.tmp <- "multiple light chain genes"
  }
  title.tmp <-
    paste0(sampleName.tmp, ", clone ", clone_id.tmp, "\n",
           data.tmp$data[[1]]@v_gene, ", ", data.tmp$data[[1]]@j_gene, "\n",
           bcrGenesLightChain.tmp)
  
  # extract tree
  tree.tmp <-
    ggtree(data.tmp$trees[[1]])
  
  plot.tmp <-
    tree.tmp +
    geom_tippoint(
      mapping = 
        aes(
          size = 
            data.tmp$data[[1]]@data$cellCount[match(tree.tmp$data$label, data.tmp$data[[1]]@data$sequence_id)] %>%
            replace_na(replace = 0)),
      shape = 19) +
    scale_size_continuous(
      "# of cells",
      limits = c(0, max(data.tmp$data[[1]]@data$cellCount)),
      breaks = seq(0, max(data.tmp$data[[1]]@data$cellCount)),
      range = c(0, 4)) +
    labs(title = title.tmp)
  
  # output tree with nodes sized by # of cells
  filename.tmp <-
    file.path(
      dirPlots,
      paste("plotTreesAaPratchetData10xClonesPublicSelectedLabelNCells",
            sampleName.tmp, clone_id.tmp, "pdf", sep = "."))
  pdf(filename.tmp, width = 6, height = 2.5 + (length(data.tmp[["trees"]][[1]]$tip.label) * 0.28))
  print(plot.tmp)
  invisible(dev.off())
  
  # # need to use trees to identify nodes of interest, then extract the inferred sequence at those nodes
  # # to do that, need to plot trees with nodes numbered, then extract the sequence at that node,
  
  # plot version with nodes labeled, for identifying pre-burst sequences
  plot.tmp <-
    tree.tmp +
    geom_nodelab(mapping = aes(label = node), nudge_x = ) +
    geom_tiplab(mapping = aes(label = node)) +
    labs(title = title.tmp)
  
  # output tree with nodes labeled by number
  filename.tmp <-
    file.path(
      dirPlots,
      paste("plotTreesAaPratchetData10xClonesPublicSelectedLabelNodes",
            sampleName.tmp, clone_id.tmp, "pdf", sep = "."))
  pdf(filename.tmp, width = 6, height = 2.5 + (length(data.tmp[["trees"]][[1]]$tip.label) * 0.28))
  print(plot.tmp)
  invisible(dev.off())
  
  # infer ancestral states
  nodeStates.tmp <-
    phangorn::ancestral.pars(
      tree = data.tmp[["trees"]][[1]],
    data = phyDat(do.call(rbind, str_split(data.tmp$data[[1]]@data$sequence_aa, pattern = "")) %>% set_rownames(data.tmp$data[[1]]@data$sequence_id), type = "AA"),
    type = "MPR",
    return = "phyDat")
  
  nodeStatesCharacter.tmp <- character()
  for (i in 1:length(nodeStates.tmp)) {
    if (names(nodeStates.tmp)[i] != "Germline") {
      nodeStatesCharacter.tmp[names(nodeStates.tmp)[i]] <-
        paste(as.character(nodeStates.tmp[i]), collapse = "")
    }
  }
  
  data.frame(node = match(names(nodeStatesCharacter.tmp), names(nodeStates.tmp)),
             nodeLabel = names(nodeStatesCharacter.tmp),
             sequence_aa = unname(nodeStatesCharacter.tmp)) %>%
    write_csv(
      file = 
        file.path(dirPlots,
                  paste("nodeStatesTreesAaPratchetData10xClonesPublicSelectedLabelNCells",
                        sampleName.tmp, clone_id.tmp, "csv", sep = ".")))
}

rm_tmp(ask=FALSE)
```


## BCR lineage inference using immcantation toolkit, for clones merged across mice

Inferring clones from multiple mice does not make sense for a number of the analyses. But where we are interested in mutation locations, this could be quite informative as it aggregates information. We will need some way to keep track of which cells come from which mouse, so that we can differentiate between mutations that are shared across mice and those that are not.

### Load AIRR-formatted data with clones and germlines

NOTE: The code will error out at this point if the upstream R script and Immcantation tools have not yet been run, as those upstream steps generate files that must be used as input here.

This loads files generated by a set of scripts from the Immcantation toolkit. That set of scripts identifies gene loci, parses files into heavy and light chains, uses the clone separation distance determined above to define clones, uses the light chain sequences to filter clones to only those with common light chain usage, and infers germline sequences.

```{r loadData10xClonesAirrAggregateMiceHeavyChainOnly, dependson="loadPreviousData"}
# get list of files with full germline alignment
fileListData10xClonesAirrAggregateMiceHeavyChainOnlyGermlineFull <-
  dir(file.path(dirOutputFilteredContigFastaAggregateMiceFiltered, "germline_full")) %>%
  grep(pattern = "igblast_final-clone-pass_germ-pass\\.tsv", value = TRUE) %>%
  file.path(dirOutputFilteredContigFastaAggregateMiceFiltered, "germline_full", .)

# get list of files with germline D region masked
fileListData10xClonesAirrAggregateMiceHeavyChainOnlyGermlineDMask <-
  str_replace(
    fileListData10xClonesAirrAggregateMiceHeavyChainOnlyGermlineFull, 
    "germline_full", "germline_d_mask")

# set trait columns to keep
traitColsData10xClonesAggregateMice <-
  c("sampleName",
    "isotypeFromBcrHChain", "seuratClustersRna",
    "junction", "junction_aa")

# load heavy chain file
data10xClonesAirrAggregateMiceHeavyChainOnly <-
  readr::read_tsv(
      file.path(
        fileListData10xClonesAirrAggregateMiceHeavyChainOnlyGermlineFull)) %>%
    # merge info from earlier analysis of cells (clusters, isotype, cell cycle phase)
    left_join(
      data10x@meta.data %>%
        dplyr::select(
          cell_id = cellBarcode, any_of(traitColsData10xClonesAggregateMice))) %>%
    mutate(cellBarcode = str_extract(sequence_id, "[ACGT]+\\-[0-9]+")) %>%
    # pull in version with germline alignment with D region masked, and merge it
    left_join(
      readr::read_tsv(
        file.path(
          fileListData10xClonesAirrAggregateMiceHeavyChainOnlyGermlineDMask)) %>%
        dplyr::select(sequence_id, germline_alignment_d_mask))

rm_tmp(ask=FALSE)
```

```{r loadData10xClonesAirrAggregateMiceLightChainOnly, dependson=c("loadData10xClonesAirrAggregateMiceHeavyChainOnly", "loadPreviousData")}
# get list of files with light chain info
fileListData10xClonesAirrAggregateMiceLightChainOnly <-
  dir(file.path(dirOutputFilteredContigFastaAggregateMiceFiltered)) %>%
  grep(pattern = "light_igblast_db-pass\\.tsv", value = TRUE) %>%
  file.path(dirOutputFilteredContigFastaAggregateMiceFiltered, .)

# load light chain file
data10xClonesAirrAggregateMiceLightChainOnly <-
  readr::read_tsv(
    file.path(
      fileListData10xClonesAirrAggregateMiceLightChainOnly)) %>%
  # merge info from earlier analysis of cells (clusters, isotype, cell cycle phase)
  left_join(
    data10x@meta.data %>%
      dplyr::select(
        cell_id = cellBarcode, any_of(traitColsData10xClones))) %>%
  mutate(cellBarcode = str_extract(sequence_id, "[ACGT]+\\-[0-9]+"))

rm_tmp(ask=FALSE)
```

```{r mergeLightChainInfoData10xClonesAirrAggregateMice, dependson=c("loadData10xClonesAirrAggregateMiceHeavyChainOnly", "loadData10xClonesAirrAggregateMiceLightChainOnly", "loadPreviousData")}
data10xClonesAirrAggregateMice <-
  data10xClonesAirrAggregateMiceHeavyChainOnly

traitColsData10xClonesAggregateMiceLightChain <-
  c("locus", "v_call", "j_call", "c_call", "junction", "junction_aa")

dataLightChain.tmp <-
  # keep light chains
  data10xClonesAirrAggregateMiceLightChainOnly %>%
  # keep only cells with 1 light chain contig
  group_by(cellBarcode) %>%
  mutate(count = n()) %>%
  dplyr::filter(count == 1)
data10xClonesAirrAggregateMice <-
  data10xClonesAirrAggregateMice %>%
  left_join(
    dataLightChain.tmp %>%
      dplyr::select(
        cellBarcode,
        all_of(traitColsData10xClonesAggregateMiceLightChain)) %>%
      magrittr::set_colnames(
        c(colnames(.)[1], paste0(colnames(.)[-1], "_light_chain")))
  )

rm_tmp(ask=FALSE)
```

```{r splitData10xClonesAirrAggregateMiceByClone, dependson="mergeLightChainInfoData10xClonesAirrAggregateMice"}
# set minimum number of distinct junction amino acid sequences to include a clone
minDistinct.tmp <- 3

data10xClonesAirrAggregateMiceSplitByClone <- list()
for (clone_id.tmp in unique(data10xClonesAirrAggregateMice$clone_id)) {
  if (data10xClonesAirrAggregateMice %>%
      dplyr::filter(clone_id %in% clone_id.tmp) %>%
      dplyr::pull(junction_aa) %>%
      unique() %>%
      length() %>%
      magrittr::is_weakly_greater_than(minDistinct.tmp))
    data10xClonesAirrAggregateMiceSplitByClone[[clone_id.tmp]] <-
      data10xClonesAirrAggregateMice %>%
      dplyr::filter(clone_id %in% clone_id.tmp) %>%
      mutate(cellCount = 1)
}

rm_tmp(ask=FALSE)
```

### Run lineage inference using dowser

```{r formatClonesData10xClonesAirrAggregateMiceByClone, dependson="splitData10xClonesAirrAggregateMiceByClone"}
data10xClonesAirrAggregateMiceSplitByCloneFormatted <- list()

# run formatClones on each clone
data10xClonesAirrAggregateMiceSplitByCloneFormatted <- list()
for (clone_id.tmp in names(data10xClonesAirrAggregateMiceSplitByClone)) {
  data10xClonesAirrAggregateMiceSplitByCloneFormatted[[clone_id.tmp]] <-
    dowser::formatClones(
      data10xClonesAirrAggregateMiceSplitByClone[[clone_id.tmp]],
      # may need to modify this to collapse sequences
      # was previously passing traitColsData10xClones as `traits`, which caused the unique values of those fields to be kept separate
      columns = traitColsData10xClonesAggregateMice, 
      num_fields = "cellCount",
      germ = "germline_alignment"
    )
}

rm_tmp(ask=FALSE)
```

#### Identify clones to focus on

```{r identifyClonesChangeOPublicSelectedAggregateMice, dependson="formatClonesData10xClonesAirrAggregateMiceByClone"}
## identify the two clones that Ollie and Sheenam used to make a transgenic mouse
# one has heavy chain IGHV1-53 and IGHJ3, light chain IGKV4-58 and IGKJ1 (clone 358_344 / 359_6)
# one has heavy chain IGHV1-76 and IGHJ1, light chain IGKV5-43 and IGKJ2 (clone 856_89 / 863_202)
minDistinctPublicSelected.tmp <- 3
clonesChangeOPublicSelectedAggregateMice <-
  data10xClonesAirrAggregateMice %>%
  dplyr::filter(
    (v_call_10x == "IGHV1-53" & j_call_10x == "IGHJ3") | # clone 358_344 / 359_6
      (v_call_10x == "IGHV1-76" & j_call_10x == "IGHJ1") # clone 856_89 / 863_202
  ) %>%
  dplyr::select(sequence_id, cell_id, v_gene = v_call_10x, j_gene = j_call_10x, junction_aa, clone_id)

# keep only the clones that have at least one cell with a BCR light chain matching the ones listed above
clonesChangeOPublicSelectedAggregateMice <-
  clonesChangeOPublicSelectedAggregateMice %>%
  mutate(
    lightChainMatch =
      case_when(
        # clone 358_344 / 359_6
        (v_gene == "IGHV1-53" & j_gene == "IGHJ3") ~
          cell_id %in%
          (filteredContigAnnotationsAggregateMiceFiltered %>%
             dplyr::filter(v_gene == "IGKV4-58" & j_gene == "IGKJ1") %>%
             dplyr::pull(barcode)),
        # clone 856_89 / 863_202
        (v_gene == "IGHV1-76" & j_gene == "IGHJ1") ~
          cell_id %in%
          (filteredContigAnnotationsAggregateMiceFiltered %>%
             dplyr::filter(v_gene == "IGKV5-43" & j_gene == "IGKJ2") %>%
             dplyr::pull(barcode)),
        TRUE ~ FALSE)) %>%
  group_by(clone_id) %>%
  mutate(
    lightChainMatchByClone = sum(lightChainMatch),
    nDistinctJunctionAa = n_distinct(junction_aa),
    cloneCount = n(),
    cellCount = NA_integer_) %>%
  dplyr::filter(
    nDistinctJunctionAa >= minDistinctPublicSelected.tmp,
    lightChainMatchByClone > 0) %>%
  ungroup()
# get cellCount for each entry
for (i in 1:nrow(clonesChangeOPublicSelectedAggregateMice)) {
  clonesChangeOPublicSelectedAggregateMice$cellCount[i] <-
    sum(data10xClonesAirrAggregateMiceSplitByCloneFormatted[[clonesChangeOPublicSelectedAggregateMice$clone_id[i]]]$data[[1]]@data$cellCount)
}

clonesChangeOPublicSelectedAggregateMice <-
  clonesChangeOPublicSelectedAggregateMice %>%
  mutate(chain = "heavy") %>%
  dplyr::select(chain, clone_id, v_gene, j_gene,
                nDistinctJunctionAa, cloneCount, cellCount) %>%
  unique() %>%
  group_by(v_gene, j_gene) %>%
  mutate(cloneIdPublicSelected = paste(v_gene, j_gene))

rm_tmp(ask=FALSE)
```

#### Make logo plots of the CDR3 for the cells from each clone

Logo plots for the cells from each of the public clones.

```{r plotLogoCdr3ClonesChangeOPublicSelectedAggregateMiceByGeneUsage, dependson="identifyClonesChangeOPublicSelectedAggregateMice"}
# potentially used in figures
clones.tmp <- unique(clonesChangeOPublicSelectedAggregateMice$cloneIdPublicSelected)
contigs.tmp <-
  lapply(
    clones.tmp,
    \(x) {
      cloneIds.tmp <-
        clonesChangeOPublicSelectedAggregateMice %>% 
        dplyr::filter(cloneIdPublicSelected %in% x) %>%
        dplyr::pull(clone_id)
      junctions.tmp <-
        unlist(
          data10xClonesAirrAggregateMiceSplitByCloneFormatted[cloneIds.tmp] %>%
            lapply(\(y) y$data[[1]]@data$sequence_id))
      return(junctions.tmp)
    }) %>%
  setNames(clones.tmp)

seqsCdr3.tmp <-
  lapply(
    contigs.tmp,
    \(x) {
      data10xVdj %>% 
        dplyr::filter(cellBarcodeContig %in% x) %>%
        dplyr::pull(junction_aa)})
      
pdf(
  file.path(dirPlots, paste0("plotLogoCdr3ClonesChangeOPublicSelectedAggregateMiceByGeneUsage.pdf")),
  width = 5, height = 2.7)
for (cloneId.tmp in names(seqsCdr3.tmp)) {
  plot.tmp <-
    ggplot() +
    ggseqlogo::geom_logo(seqsCdr3.tmp[[cloneId.tmp]], method = "bits") +
    ggseqlogo::theme_logo() +
    labs(x = "position", title = cloneId.tmp) +
    theme(legend.text = element_text(size = 7),
          legend.key.size = unit(0.2, "in"))
  print(plot.tmp)
}
invisible(dev.off())

rm_tmp(ask = FALSE)
```

# Output R session information

```{r output_session_info, cache=FALSE}
miscHelpers::print_session_info()
```